package internal

import (
	"go/token"
	"reflect"
)

var binFuncs = map[string]BinaryExprFunc{
	// int
	"int" + token.ADD.String() + "int":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() + y.Int())) },
	"int" + token.SUB.String() + "int":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() - y.Int())) },
	"int" + token.MUL.String() + "int":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() * y.Int())) },
	"int" + token.QUO.String() + "int":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() / y.Int())) },
	"int" + token.REM.String() + "int":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() % y.Int())) },
	"int" + token.AND.String() + "int":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() & y.Int())) },
	"int" + token.OR.String() + "int":      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() | y.Int())) },
	"int" + token.XOR.String() + "int":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() ^ y.Int())) },
	"int" + token.SHL.String() + "int":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() << uint64(y.Int()))) },
	"int" + token.SHR.String() + "int":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() >> uint64(y.Int()))) },
	"int" + token.AND_NOT.String() + "int": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() &^ y.Int())) },
	"int" + token.EQL.String() + "int":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() == y.Int()) },
	"int" + token.LSS.String() + "int":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() < y.Int()) },
	"int" + token.GTR.String() + "int":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() > y.Int()) },
	"int" + token.NEQ.String() + "int":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() != y.Int()) },
	"int" + token.LEQ.String() + "int":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() <= y.Int()) },
	"int" + token.GEQ.String() + "int":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() >= y.Int()) },
	// int8
	"int8" + token.ADD.String() + "int8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() + y.Int())) },
	"int8" + token.SUB.String() + "int8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() - y.Int())) },
	"int8" + token.MUL.String() + "int8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() * y.Int())) },
	"int8" + token.QUO.String() + "int8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() / y.Int())) },
	"int8" + token.REM.String() + "int8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() % y.Int())) },
	"int8" + token.AND.String() + "int8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() & y.Int())) },
	"int8" + token.OR.String() + "int8":      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() | y.Int())) },
	"int8" + token.XOR.String() + "int8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() ^ y.Int())) },
	"int8" + token.SHL.String() + "int8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() << uint64(y.Int()))) },
	"int8" + token.SHR.String() + "int8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() >> uint64(y.Int()))) },
	"int8" + token.AND_NOT.String() + "int8": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() &^ y.Int())) },
	"int8" + token.EQL.String() + "int8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() == y.Int()) },
	"int8" + token.LSS.String() + "int8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() < y.Int()) },
	"int8" + token.GTR.String() + "int8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() > y.Int()) },
	"int8" + token.NEQ.String() + "int8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() != y.Int()) },
	"int8" + token.LEQ.String() + "int8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() <= y.Int()) },
	"int8" + token.GEQ.String() + "int8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() >= y.Int()) },
	// int16
	"int16" + token.ADD.String() + "int16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() + y.Int())) },
	"int16" + token.SUB.String() + "int16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() - y.Int())) },
	"int16" + token.MUL.String() + "int16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() * y.Int())) },
	"int16" + token.QUO.String() + "int16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() / y.Int())) },
	"int16" + token.REM.String() + "int16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() % y.Int())) },
	"int16" + token.AND.String() + "int16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() & y.Int())) },
	"int16" + token.OR.String() + "int16":      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() | y.Int())) },
	"int16" + token.XOR.String() + "int16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() ^ y.Int())) },
	"int16" + token.SHL.String() + "int16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() << uint64(y.Int()))) },
	"int16" + token.SHR.String() + "int16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() >> uint64(y.Int()))) },
	"int16" + token.AND_NOT.String() + "int16": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() &^ y.Int())) },
	"int16" + token.EQL.String() + "int16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() == y.Int()) },
	"int16" + token.LSS.String() + "int16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() < y.Int()) },
	"int16" + token.GTR.String() + "int16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() > y.Int()) },
	"int16" + token.NEQ.String() + "int16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() != y.Int()) },
	"int16" + token.LEQ.String() + "int16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() <= y.Int()) },
	"int16" + token.GEQ.String() + "int16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() >= y.Int()) },
	// int32
	"int32" + token.ADD.String() + "int32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() + y.Int())) },
	"int32" + token.SUB.String() + "int32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() - y.Int())) },
	"int32" + token.MUL.String() + "int32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() * y.Int())) },
	"int32" + token.QUO.String() + "int32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() / y.Int())) },
	"int32" + token.REM.String() + "int32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() % y.Int())) },
	"int32" + token.AND.String() + "int32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() & y.Int())) },
	"int32" + token.OR.String() + "int32":      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() | y.Int())) },
	"int32" + token.XOR.String() + "int32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() ^ y.Int())) },
	"int32" + token.SHL.String() + "int32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() << uint64(y.Int()))) },
	"int32" + token.SHR.String() + "int32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() >> uint64(y.Int()))) },
	"int32" + token.AND_NOT.String() + "int32": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() &^ y.Int())) },
	"int32" + token.EQL.String() + "int32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() == y.Int()) },
	"int32" + token.LSS.String() + "int32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() < y.Int()) },
	"int32" + token.GTR.String() + "int32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() > y.Int()) },
	"int32" + token.NEQ.String() + "int32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() != y.Int()) },
	"int32" + token.LEQ.String() + "int32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() <= y.Int()) },
	"int32" + token.GEQ.String() + "int32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() >= y.Int()) },
	// int64
	"int64" + token.ADD.String() + "int64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() + y.Int()) },
	"int64" + token.SUB.String() + "int64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() - y.Int()) },
	"int64" + token.MUL.String() + "int64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() * y.Int()) },
	"int64" + token.QUO.String() + "int64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() / y.Int()) },
	"int64" + token.REM.String() + "int64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() % y.Int()) },
	"int64" + token.AND.String() + "int64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() & y.Int()) },
	"int64" + token.OR.String() + "int64":      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() | y.Int()) },
	"int64" + token.XOR.String() + "int64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() ^ y.Int()) },
	"int64" + token.SHL.String() + "int64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() << uint64(y.Int())) },
	"int64" + token.SHR.String() + "int64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() >> uint64(y.Int())) },
	"int64" + token.AND_NOT.String() + "int64": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() &^ y.Int()) },
	"int64" + token.EQL.String() + "int64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() == y.Int()) },
	"int64" + token.LSS.String() + "int64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() < y.Int()) },
	"int64" + token.GTR.String() + "int64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() > y.Int()) },
	"int64" + token.NEQ.String() + "int64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() != y.Int()) },
	"int64" + token.LEQ.String() + "int64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() <= y.Int()) },
	"int64" + token.GEQ.String() + "int64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() >= y.Int()) },
	// uint
	"uint" + token.ADD.String() + "uint":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() + y.Uint())) },
	"uint" + token.SUB.String() + "uint":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() - y.Uint())) },
	"uint" + token.MUL.String() + "uint":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() * y.Uint())) },
	"uint" + token.QUO.String() + "uint":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() / y.Uint())) },
	"uint" + token.REM.String() + "uint":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() % y.Uint())) },
	"uint" + token.AND.String() + "uint":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() & y.Uint())) },
	"uint" + token.OR.String() + "uint":      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() | y.Uint())) },
	"uint" + token.XOR.String() + "uint":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() ^ y.Uint())) },
	"uint" + token.SHL.String() + "uint":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() << y.Uint())) },
	"uint" + token.SHR.String() + "uint":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() >> y.Uint())) },
	"uint" + token.AND_NOT.String() + "uint": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() &^ y.Uint())) },
	"uint" + token.EQL.String() + "uint":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() == y.Uint()) },
	"uint" + token.LSS.String() + "uint":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() < y.Uint()) },
	"uint" + token.GTR.String() + "uint":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() > y.Uint()) },
	"uint" + token.NEQ.String() + "uint":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() != y.Uint()) },
	"uint" + token.LEQ.String() + "uint":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() <= y.Uint()) },
	"uint" + token.GEQ.String() + "uint":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() >= y.Uint()) },
	// uint8
	"uint8" + token.ADD.String() + "uint8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() + y.Uint())) },
	"uint8" + token.SUB.String() + "uint8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() - y.Uint())) },
	"uint8" + token.MUL.String() + "uint8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() * y.Uint())) },
	"uint8" + token.QUO.String() + "uint8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() / y.Uint())) },
	"uint8" + token.REM.String() + "uint8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() % y.Uint())) },
	"uint8" + token.AND.String() + "uint8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() & y.Uint())) },
	"uint8" + token.OR.String() + "uint8":      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() | y.Uint())) },
	"uint8" + token.XOR.String() + "uint8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() ^ y.Uint())) },
	"uint8" + token.SHL.String() + "uint8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() << y.Uint())) },
	"uint8" + token.SHR.String() + "uint8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() >> y.Uint())) },
	"uint8" + token.AND_NOT.String() + "uint8": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() &^ y.Uint())) },
	"uint8" + token.EQL.String() + "uint8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() == y.Uint()) },
	"uint8" + token.LSS.String() + "uint8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() < y.Uint()) },
	"uint8" + token.GTR.String() + "uint8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() > y.Uint()) },
	"uint8" + token.NEQ.String() + "uint8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() != y.Uint()) },
	"uint8" + token.LEQ.String() + "uint8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() <= y.Uint()) },
	"uint8" + token.GEQ.String() + "uint8":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() >= y.Uint()) },
	// uint16
	"uint16" + token.ADD.String() + "uint16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() + y.Uint())) },
	"uint16" + token.SUB.String() + "uint16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() - y.Uint())) },
	"uint16" + token.MUL.String() + "uint16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() * y.Uint())) },
	"uint16" + token.QUO.String() + "uint16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() / y.Uint())) },
	"uint16" + token.REM.String() + "uint16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() % y.Uint())) },
	"uint16" + token.AND.String() + "uint16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() & y.Uint())) },
	"uint16" + token.OR.String() + "uint16":      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() | y.Uint())) },
	"uint16" + token.XOR.String() + "uint16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() ^ y.Uint())) },
	"uint16" + token.SHL.String() + "uint16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() << y.Uint())) },
	"uint16" + token.SHR.String() + "uint16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() >> y.Uint())) },
	"uint16" + token.AND_NOT.String() + "uint16": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() &^ y.Uint())) },
	"uint16" + token.EQL.String() + "uint16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() == y.Uint()) },
	"uint16" + token.LSS.String() + "uint16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() < y.Uint()) },
	"uint16" + token.GTR.String() + "uint16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() > y.Uint()) },
	"uint16" + token.NEQ.String() + "uint16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() != y.Uint()) },
	"uint16" + token.LEQ.String() + "uint16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() <= y.Uint()) },
	"uint16" + token.GEQ.String() + "uint16":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() >= y.Uint()) },
	// uint32
	"uint32" + token.ADD.String() + "uint32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() + y.Uint())) },
	"uint32" + token.SUB.String() + "uint32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() - y.Uint())) },
	"uint32" + token.MUL.String() + "uint32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() * y.Uint())) },
	"uint32" + token.QUO.String() + "uint32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() / y.Uint())) },
	"uint32" + token.REM.String() + "uint32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() % y.Uint())) },
	"uint32" + token.AND.String() + "uint32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() & y.Uint())) },
	"uint32" + token.OR.String() + "uint32":      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() | y.Uint())) },
	"uint32" + token.XOR.String() + "uint32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() ^ y.Uint())) },
	"uint32" + token.SHL.String() + "uint32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() << y.Uint())) },
	"uint32" + token.SHR.String() + "uint32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() >> y.Uint())) },
	"uint32" + token.AND_NOT.String() + "uint32": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() &^ y.Uint())) },
	"uint32" + token.EQL.String() + "uint32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() == y.Uint()) },
	"uint32" + token.LSS.String() + "uint32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() < y.Uint()) },
	"uint32" + token.GTR.String() + "uint32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() > y.Uint()) },
	"uint32" + token.NEQ.String() + "uint32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() != y.Uint()) },
	"uint32" + token.LEQ.String() + "uint32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() <= y.Uint()) },
	"uint32" + token.GEQ.String() + "uint32":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() >= y.Uint()) },
	// uint64
	"uint64" + token.ADD.String() + "uint64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() + y.Uint()) },
	"uint64" + token.SUB.String() + "uint64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() - y.Uint()) },
	"uint64" + token.MUL.String() + "uint64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() * y.Uint()) },
	"uint64" + token.QUO.String() + "uint64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() / y.Uint()) },
	"uint64" + token.REM.String() + "uint64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() % y.Uint()) },
	"uint64" + token.AND.String() + "uint64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() & y.Uint()) },
	"uint64" + token.OR.String() + "uint64":      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() | y.Uint()) },
	"uint64" + token.XOR.String() + "uint64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() ^ y.Uint()) },
	"uint64" + token.SHL.String() + "uint64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() << y.Uint()) },
	"uint64" + token.SHR.String() + "uint64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() >> y.Uint()) },
	"uint64" + token.AND_NOT.String() + "uint64": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() &^ y.Uint()) },
	"uint64" + token.EQL.String() + "uint64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() == y.Uint()) },
	"uint64" + token.LSS.String() + "uint64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() < y.Uint()) },
	"uint64" + token.GTR.String() + "uint64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() > y.Uint()) },
	"uint64" + token.NEQ.String() + "uint64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() != y.Uint()) },
	"uint64" + token.LEQ.String() + "uint64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() <= y.Uint()) },
	"uint64" + token.GEQ.String() + "uint64":     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() >= y.Uint()) },
	// float64
	"float64" + token.ADD.String() + "float64": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() + y.Float()) },
	"float64" + token.SUB.String() + "float64": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() - y.Float()) },
	"float64" + token.MUL.String() + "float64": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() * y.Float()) },
	"float64" + token.QUO.String() + "float64": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() / y.Float()) },
	"float64" + token.EQL.String() + "float64": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() == y.Float()) },
	"float64" + token.LSS.String() + "float64": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() < y.Float()) },
	"float64" + token.GTR.String() + "float64": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() > y.Float()) },
	"float64" + token.NEQ.String() + "float64": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() != y.Float()) },
	"float64" + token.LEQ.String() + "float64": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() <= y.Float()) },
	"float64" + token.GEQ.String() + "float64": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() >= y.Float()) },
	// string
	"string" + token.ADD.String() + "string": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.String() + y.String()) },
	"string" + token.EQL.String() + "string": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.String() == y.String()) },
	"string" + token.LSS.String() + "string": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.String() < y.String()) },
	"string" + token.GTR.String() + "string": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.String() > y.String()) },
	"string" + token.NEQ.String() + "string": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.String() != y.String()) },
	"string" + token.LEQ.String() + "string": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.String() <= y.String()) },
	"string" + token.GEQ.String() + "string": func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.String() >= y.String()) },
}
