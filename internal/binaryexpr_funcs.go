package internal

import (
	"fmt"
	"go/token"
	"reflect"
)

var binFuncs map[string]BinaryExprFunc

func init() {
	binFuncs = map[string]BinaryExprFunc{
		// int
		fmt.Sprintf("int%dint", token.ADD):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() + y.Int())) },
		fmt.Sprintf("int%dint", token.SUB):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() - y.Int())) },
		fmt.Sprintf("int%dint", token.MUL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() * y.Int())) },
		fmt.Sprintf("int%dint", token.QUO):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() / y.Int())) },
		fmt.Sprintf("int%dint", token.REM):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() % y.Int())) },
		fmt.Sprintf("int%dint", token.AND):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() & y.Int())) },
		fmt.Sprintf("int%dint", token.OR):      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() | y.Int())) },
		fmt.Sprintf("int%dint", token.XOR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() ^ y.Int())) },
		fmt.Sprintf("int%dint", token.SHL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() << uint64(y.Int()))) },
		fmt.Sprintf("int%dint", token.SHR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() >> uint64(y.Int()))) },
		fmt.Sprintf("int%dint", token.AND_NOT): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int(x.Int() &^ y.Int())) },
		fmt.Sprintf("int%dint", token.EQL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() == y.Int()) },
		fmt.Sprintf("int%dint", token.LSS):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() < y.Int()) },
		fmt.Sprintf("int%dint", token.GTR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() > y.Int()) },
		fmt.Sprintf("int%dint", token.NEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() != y.Int()) },
		fmt.Sprintf("int%dint", token.LEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() <= y.Int()) },
		fmt.Sprintf("int%dint", token.GEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() >= y.Int()) },
		// int8
		fmt.Sprintf("int8%dint8", token.ADD):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() + y.Int())) },
		fmt.Sprintf("int8%dint8", token.SUB):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() - y.Int())) },
		fmt.Sprintf("int8%dint8", token.MUL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() * y.Int())) },
		fmt.Sprintf("int8%dint8", token.QUO):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() / y.Int())) },
		fmt.Sprintf("int8%dint8", token.REM):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() % y.Int())) },
		fmt.Sprintf("int8%dint8", token.AND):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() & y.Int())) },
		fmt.Sprintf("int8%dint8", token.OR):      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() | y.Int())) },
		fmt.Sprintf("int8%dint8", token.XOR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() ^ y.Int())) },
		fmt.Sprintf("int8%dint8", token.SHL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() << uint64(y.Int()))) },
		fmt.Sprintf("int8%dint8", token.SHR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() >> uint64(y.Int()))) },
		fmt.Sprintf("int8%dint8", token.AND_NOT): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int8(x.Int() &^ y.Int())) },
		fmt.Sprintf("int8%dint8", token.EQL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() == y.Int()) },
		fmt.Sprintf("int8%dint8", token.LSS):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() < y.Int()) },
		fmt.Sprintf("int8%dint8", token.GTR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() > y.Int()) },
		fmt.Sprintf("int8%dint8", token.NEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() != y.Int()) },
		fmt.Sprintf("int8%dint8", token.LEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() <= y.Int()) },
		fmt.Sprintf("int8%dint8", token.GEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() >= y.Int()) },
		// int16
		fmt.Sprintf("int16%dint16", token.ADD):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() + y.Int())) },
		fmt.Sprintf("int16%dint16", token.SUB):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() - y.Int())) },
		fmt.Sprintf("int16%dint16", token.MUL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() * y.Int())) },
		fmt.Sprintf("int16%dint16", token.QUO):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() / y.Int())) },
		fmt.Sprintf("int16%dint16", token.REM):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() % y.Int())) },
		fmt.Sprintf("int16%dint16", token.AND):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() & y.Int())) },
		fmt.Sprintf("int16%dint16", token.OR):      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() | y.Int())) },
		fmt.Sprintf("int16%dint16", token.XOR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() ^ y.Int())) },
		fmt.Sprintf("int16%dint16", token.SHL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() << uint64(y.Int()))) },
		fmt.Sprintf("int16%dint16", token.SHR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() >> uint64(y.Int()))) },
		fmt.Sprintf("int16%dint16", token.AND_NOT): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int16(x.Int() &^ y.Int())) },
		fmt.Sprintf("int16%dint16", token.EQL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() == y.Int()) },
		fmt.Sprintf("int16%dint16", token.LSS):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() < y.Int()) },
		fmt.Sprintf("int16%dint16", token.GTR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() > y.Int()) },
		fmt.Sprintf("int16%dint16", token.NEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() != y.Int()) },
		fmt.Sprintf("int16%dint16", token.LEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() <= y.Int()) },
		fmt.Sprintf("int16%dint16", token.GEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() >= y.Int()) },
		// int32
		fmt.Sprintf("int32%dint32", token.ADD):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() + y.Int())) },
		fmt.Sprintf("int32%dint32", token.SUB):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() - y.Int())) },
		fmt.Sprintf("int32%dint32", token.MUL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() * y.Int())) },
		fmt.Sprintf("int32%dint32", token.QUO):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() / y.Int())) },
		fmt.Sprintf("int32%dint32", token.REM):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() % y.Int())) },
		fmt.Sprintf("int32%dint32", token.AND):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() & y.Int())) },
		fmt.Sprintf("int32%dint32", token.OR):      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() | y.Int())) },
		fmt.Sprintf("int32%dint32", token.XOR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() ^ y.Int())) },
		fmt.Sprintf("int32%dint32", token.SHL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() << uint64(y.Int()))) },
		fmt.Sprintf("int32%dint32", token.SHR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() >> uint64(y.Int()))) },
		fmt.Sprintf("int32%dint32", token.AND_NOT): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(int32(x.Int() &^ y.Int())) },
		fmt.Sprintf("int32%dint32", token.EQL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() == y.Int()) },
		fmt.Sprintf("int32%dint32", token.LSS):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() < y.Int()) },
		fmt.Sprintf("int32%dint32", token.GTR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() > y.Int()) },
		fmt.Sprintf("int32%dint32", token.NEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() != y.Int()) },
		fmt.Sprintf("int32%dint32", token.LEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() <= y.Int()) },
		fmt.Sprintf("int32%dint32", token.GEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() >= y.Int()) },
		// int64
		fmt.Sprintf("int64%dint64", token.ADD):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() + y.Int()) },
		fmt.Sprintf("int64%dint64", token.SUB):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() - y.Int()) },
		fmt.Sprintf("int64%dint64", token.MUL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() * y.Int()) },
		fmt.Sprintf("int64%dint64", token.QUO):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() / y.Int()) },
		fmt.Sprintf("int64%dint64", token.REM):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() % y.Int()) },
		fmt.Sprintf("int64%dint64", token.AND):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() & y.Int()) },
		fmt.Sprintf("int64%dint64", token.OR):      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() | y.Int()) },
		fmt.Sprintf("int64%dint64", token.XOR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() ^ y.Int()) },
		fmt.Sprintf("int64%dint64", token.SHL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() << uint64(y.Int())) },
		fmt.Sprintf("int64%dint64", token.SHR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() >> uint64(y.Int())) },
		fmt.Sprintf("int64%dint64", token.AND_NOT): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() &^ y.Int()) },
		fmt.Sprintf("int64%dint64", token.EQL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() == y.Int()) },
		fmt.Sprintf("int64%dint64", token.LSS):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() < y.Int()) },
		fmt.Sprintf("int64%dint64", token.GTR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() > y.Int()) },
		fmt.Sprintf("int64%dint64", token.NEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() != y.Int()) },
		fmt.Sprintf("int64%dint64", token.LEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() <= y.Int()) },
		fmt.Sprintf("int64%dint64", token.GEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Int() >= y.Int()) },
		// uint
		fmt.Sprintf("uint%duint", token.ADD):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() + y.Uint())) },
		fmt.Sprintf("uint%duint", token.SUB):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() - y.Uint())) },
		fmt.Sprintf("uint%duint", token.MUL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() * y.Uint())) },
		fmt.Sprintf("uint%duint", token.QUO):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() / y.Uint())) },
		fmt.Sprintf("uint%duint", token.REM):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() % y.Uint())) },
		fmt.Sprintf("uint%duint", token.AND):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() & y.Uint())) },
		fmt.Sprintf("uint%duint", token.OR):      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() | y.Uint())) },
		fmt.Sprintf("uint%duint", token.XOR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() ^ y.Uint())) },
		fmt.Sprintf("uint%duint", token.SHL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() << y.Uint())) },
		fmt.Sprintf("uint%duint", token.SHR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() >> y.Uint())) },
		fmt.Sprintf("uint%duint", token.AND_NOT): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint(x.Uint() &^ y.Uint())) },
		fmt.Sprintf("uint%duint", token.EQL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() == y.Uint()) },
		fmt.Sprintf("uint%duint", token.LSS):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() < y.Uint()) },
		fmt.Sprintf("uint%duint", token.GTR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() > y.Uint()) },
		fmt.Sprintf("uint%duint", token.NEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() != y.Uint()) },
		fmt.Sprintf("uint%duint", token.LEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() <= y.Uint()) },
		fmt.Sprintf("uint%duint", token.GEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() >= y.Uint()) },
		// uint8
		fmt.Sprintf("uint8%duint8", token.ADD):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() + y.Uint())) },
		fmt.Sprintf("uint8%duint8", token.SUB):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() - y.Uint())) },
		fmt.Sprintf("uint8%duint8", token.MUL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() * y.Uint())) },
		fmt.Sprintf("uint8%duint8", token.QUO):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() / y.Uint())) },
		fmt.Sprintf("uint8%duint8", token.REM):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() % y.Uint())) },
		fmt.Sprintf("uint8%duint8", token.AND):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() & y.Uint())) },
		fmt.Sprintf("uint8%duint8", token.OR):      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() | y.Uint())) },
		fmt.Sprintf("uint8%duint8", token.XOR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() ^ y.Uint())) },
		fmt.Sprintf("uint8%duint8", token.SHL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() << y.Uint())) },
		fmt.Sprintf("uint8%duint8", token.SHR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() >> y.Uint())) },
		fmt.Sprintf("uint8%duint8", token.AND_NOT): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint8(x.Uint() &^ y.Uint())) },
		fmt.Sprintf("uint8%duint8", token.EQL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() == y.Uint()) },
		fmt.Sprintf("uint8%duint8", token.LSS):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() < y.Uint()) },
		fmt.Sprintf("uint8%duint8", token.GTR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() > y.Uint()) },
		fmt.Sprintf("uint8%duint8", token.NEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() != y.Uint()) },
		fmt.Sprintf("uint8%duint8", token.LEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() <= y.Uint()) },
		fmt.Sprintf("uint8%duint8", token.GEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() >= y.Uint()) },
		// uint16
		fmt.Sprintf("uint16%duint16", token.ADD):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() + y.Uint())) },
		fmt.Sprintf("uint16%duint16", token.SUB):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() - y.Uint())) },
		fmt.Sprintf("uint16%duint16", token.MUL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() * y.Uint())) },
		fmt.Sprintf("uint16%duint16", token.QUO):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() / y.Uint())) },
		fmt.Sprintf("uint16%duint16", token.REM):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() % y.Uint())) },
		fmt.Sprintf("uint16%duint16", token.AND):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() & y.Uint())) },
		fmt.Sprintf("uint16%duint16", token.OR):      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() | y.Uint())) },
		fmt.Sprintf("uint16%duint16", token.XOR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() ^ y.Uint())) },
		fmt.Sprintf("uint16%duint16", token.SHL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() << y.Uint())) },
		fmt.Sprintf("uint16%duint16", token.SHR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() >> y.Uint())) },
		fmt.Sprintf("uint16%duint16", token.AND_NOT): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint16(x.Uint() &^ y.Uint())) },
		fmt.Sprintf("uint16%duint16", token.EQL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() == y.Uint()) },
		fmt.Sprintf("uint16%duint16", token.LSS):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() < y.Uint()) },
		fmt.Sprintf("uint16%duint16", token.GTR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() > y.Uint()) },
		fmt.Sprintf("uint16%duint16", token.NEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() != y.Uint()) },
		fmt.Sprintf("uint16%duint16", token.LEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() <= y.Uint()) },
		fmt.Sprintf("uint16%duint16", token.GEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() >= y.Uint()) },
		// uint32
		fmt.Sprintf("uint32%duint32", token.ADD):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() + y.Uint())) },
		fmt.Sprintf("uint32%duint32", token.SUB):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() - y.Uint())) },
		fmt.Sprintf("uint32%duint32", token.MUL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() * y.Uint())) },
		fmt.Sprintf("uint32%duint32", token.QUO):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() / y.Uint())) },
		fmt.Sprintf("uint32%duint32", token.REM):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() % y.Uint())) },
		fmt.Sprintf("uint32%duint32", token.AND):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() & y.Uint())) },
		fmt.Sprintf("uint32%duint32", token.OR):      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() | y.Uint())) },
		fmt.Sprintf("uint32%duint32", token.XOR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() ^ y.Uint())) },
		fmt.Sprintf("uint32%duint32", token.SHL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() << y.Uint())) },
		fmt.Sprintf("uint32%duint32", token.SHR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() >> y.Uint())) },
		fmt.Sprintf("uint32%duint32", token.AND_NOT): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(uint32(x.Uint() &^ y.Uint())) },
		fmt.Sprintf("uint32%duint32", token.EQL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() == y.Uint()) },
		fmt.Sprintf("uint32%duint32", token.LSS):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() < y.Uint()) },
		fmt.Sprintf("uint32%duint32", token.GTR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() > y.Uint()) },
		fmt.Sprintf("uint32%duint32", token.NEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() != y.Uint()) },
		fmt.Sprintf("uint32%duint32", token.LEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() <= y.Uint()) },
		fmt.Sprintf("uint32%duint32", token.GEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() >= y.Uint()) },
		// uint64
		fmt.Sprintf("uint64%duint64", token.ADD):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() + y.Uint()) },
		fmt.Sprintf("uint64%duint64", token.SUB):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() - y.Uint()) },
		fmt.Sprintf("uint64%duint64", token.MUL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() * y.Uint()) },
		fmt.Sprintf("uint64%duint64", token.QUO):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() / y.Uint()) },
		fmt.Sprintf("uint64%duint64", token.REM):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() % y.Uint()) },
		fmt.Sprintf("uint64%duint64", token.AND):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() & y.Uint()) },
		fmt.Sprintf("uint64%duint64", token.OR):      func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() | y.Uint()) },
		fmt.Sprintf("uint64%duint64", token.XOR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() ^ y.Uint()) },
		fmt.Sprintf("uint64%duint64", token.SHL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() << y.Uint()) },
		fmt.Sprintf("uint64%duint64", token.SHR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() >> y.Uint()) },
		fmt.Sprintf("uint64%duint64", token.AND_NOT): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() &^ y.Uint()) },
		fmt.Sprintf("uint64%duint64", token.EQL):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() == y.Uint()) },
		fmt.Sprintf("uint64%duint64", token.LSS):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() < y.Uint()) },
		fmt.Sprintf("uint64%duint64", token.GTR):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() > y.Uint()) },
		fmt.Sprintf("uint64%duint64", token.NEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() != y.Uint()) },
		fmt.Sprintf("uint64%duint64", token.LEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() <= y.Uint()) },
		fmt.Sprintf("uint64%duint64", token.GEQ):     func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Uint() >= y.Uint()) },
		// float64
		fmt.Sprintf("float64%dfloat64", token.ADD): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() + y.Float()) },
		fmt.Sprintf("float64%dfloat64", token.SUB): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() - y.Float()) },
		fmt.Sprintf("float64%dfloat64", token.MUL): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() * y.Float()) },
		fmt.Sprintf("float64%dfloat64", token.QUO): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() / y.Float()) },
		fmt.Sprintf("float64%dfloat64", token.EQL): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() == y.Float()) },
		fmt.Sprintf("float64%dfloat64", token.LSS): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() < y.Float()) },
		fmt.Sprintf("float64%dfloat64", token.GTR): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() > y.Float()) },
		fmt.Sprintf("float64%dfloat64", token.NEQ): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() != y.Float()) },
		fmt.Sprintf("float64%dfloat64", token.LEQ): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() <= y.Float()) },
		fmt.Sprintf("float64%dfloat64", token.GEQ): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() >= y.Float()) },
		// float32
		fmt.Sprintf("float32%dfloat32", token.ADD): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(float32(x.Float() + y.Float())) },
		fmt.Sprintf("float32%dfloat32", token.SUB): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(float32(x.Float() - y.Float())) },
		fmt.Sprintf("float32%dfloat32", token.MUL): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(float32(x.Float() * y.Float())) },
		fmt.Sprintf("float32%dfloat32", token.QUO): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(float32(x.Float() / y.Float())) },
		fmt.Sprintf("float32%dfloat32", token.EQL): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() == y.Float()) },
		fmt.Sprintf("float32%dfloat32", token.LSS): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() < y.Float()) },
		fmt.Sprintf("float32%dfloat32", token.GTR): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() > y.Float()) },
		fmt.Sprintf("float32%dfloat32", token.NEQ): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() != y.Float()) },
		fmt.Sprintf("float32%dfloat32", token.LEQ): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() <= y.Float()) },
		fmt.Sprintf("float32%dfloat32", token.GEQ): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.Float() >= y.Float()) },
		// string
		fmt.Sprintf("string%dstring", token.ADD): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.String() + y.String()) },
		fmt.Sprintf("string%dstring", token.EQL): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.String() == y.String()) },
		fmt.Sprintf("string%dstring", token.LSS): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.String() < y.String()) },
		fmt.Sprintf("string%dstring", token.GTR): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.String() > y.String()) },
		fmt.Sprintf("string%dstring", token.NEQ): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.String() != y.String()) },
		fmt.Sprintf("string%dstring", token.LEQ): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.String() <= y.String()) },
		fmt.Sprintf("string%dstring", token.GEQ): func(x, y reflect.Value) reflect.Value { return reflect.ValueOf(x.String() >= y.String()) },
	}
}
