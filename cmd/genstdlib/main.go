package main

import (
	"fmt"
	"go/ast"
	"go/build"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strings"
)

var excludedPackages = []string{
	"unsafe",
	"debug",
	"reflect",
	"runtime",
	"testing",
	"go",
	"syscall",
}

// ExcludedSymbol defines a symbol to be excluded from a specific package.
type ExcludedSymbol struct {
	Package string
	Symbol  string
}

var excludedSymbols = []ExcludedSymbol{
	{"hash/crc64", "ECMA"},
	{"hash/crc64", "ISO"},
	{"math", "MaxUint"},
	{"math", "MaxUint64"},
}

func main() {
	// Get all standard library packages.
	stdPkgs, err := getStdPkgs()
	if err != nil {
		log.Fatalf("failed to get standard library packages: %v", err)
	}

	// Create the output file.
	outFile, err := os.Create("../../internal/stdlib_generated.go")
	if err != nil {
		log.Fatalf("failed to create output file: %v", err)
	}
	defer outFile.Close()

	// Collect used packages and their exported symbols
	usedPkgs := make([]string, 0)
	usedPkgFuncs := make(map[string]struct {
		PkgName string
		Funcs   []string
		Types   []string
	})

	for _, pkg := range stdPkgs {
		isExcluded := false
		for _, excluded := range excludedPackages {
			if pkg == excluded || strings.HasPrefix(pkg, excluded+"/") {
				isExcluded = true
				break
			}
		}
		if isExcluded {
			continue
		}
		pkgName, funcs, types, err := getExportedFunctionsAndTypes(pkg)
		if err != nil {
			log.Printf("failed to get exported functions for package %s: %v", pkg, err)
			continue
		}
		if err != nil {
			log.Printf("failed to get exported types for package %s: %v", pkg, err)
			continue
		}
		if len(funcs) > 0 {
			usedPkgs = append(usedPkgs, pkg)
			usedPkgFuncs[pkg] = struct {
				PkgName string
				Funcs   []string
				Types   []string
			}{pkgName, funcs, types}
		}
	}

	// Write the header.
	fmt.Fprintln(outFile, "// Code generated by cmd/genstdlib/main.go; DO NOT EDIT.")
	fmt.Fprintln(outFile, "package internal")
	fmt.Fprintln(outFile, "")

	// Assign unique aliases for each package
	pkgAliases := make(map[string]string)
	for idx, pkg := range usedPkgs {
		alias := fmt.Sprintf("i%d", idx+1)
		pkgAliases[pkg] = alias
	}

	fmt.Fprintln(outFile, "import (")
	fmt.Fprintln(outFile, "\t\"reflect\"")
	for _, pkg := range usedPkgs {
		alias := pkgAliases[pkg]
		fmt.Fprintf(outFile, "\t%s \"%s\"\n", alias, pkg)
	}
	fmt.Fprintln(outFile, ")")
	fmt.Fprintln(outFile, "\nvar stdpkg = map[string]map[string]reflect.Value{}")
	fmt.Fprintln(outFile, "\nfunc init() {")

	for _, pkg := range usedPkgs {
		pkgInfo := usedPkgFuncs[pkg]
		alias := pkgAliases[pkg]
		fmt.Fprintf(outFile, "\tstdpkg[\"%s\"] = map[string]reflect.Value{\n", pkg)
		for _, fun := range pkgInfo.Funcs {
			isExcluded := false
			for _, excluded := range excludedSymbols {
				if pkg == excluded.Package && fun == excluded.Symbol {
					isExcluded = true
					break
				}
			}
			if isExcluded {
				continue
			}
			fmt.Fprintf(outFile, "\t\t\"%s\": reflect.ValueOf(%s.%s),\n", fun, alias, fun)
		}
		for _, typ := range pkgInfo.Types {
			fmt.Fprintf(outFile, "\t\t\"%s\": reflect.ValueOf(%s.%s{}),\n", typ, alias, typ)
		}
		fmt.Fprintln(outFile, "\t}")
	}

	fmt.Fprintln(outFile, "}")
}

func getStdPkgs() ([]string, error) {
	// This is a simplified approach. A more robust solution would be to
	// inspect the GOROOT environment variable.
	return []string{
		"archive/tar",
		"archive/zip",
		"bufio",
		"bytes",
		"compress/bzip2",
		"compress/flate",
		"compress/gzip",
		"compress/lzw",
		"compress/zlib",
		"container/heap",
		"container/list",
		"container/ring",
		"context",
		"crypto",
		"crypto/aes",
		"crypto/cipher",
		"crypto/des",
		"crypto/dsa",
		"crypto/ecdsa",
		"crypto/ed25519",
		"crypto/elliptic",
		"crypto/hmac",
		"crypto/md5",
		"crypto/rand",
		"crypto/rc4",
		"crypto/rsa",
		"crypto/sha1",
		"crypto/sha256",
		"crypto/sha512",
		"crypto/subtle",
		"crypto/tls",
		"crypto/x509",
		"crypto/x509/pkix",
		"database/sql",
		"database/sql/driver",
		"debug/buildinfo",
		"debug/dwarf",
		"debug/elf",
		"debug/gosym",
		"debug/macho",
		"debug/pe",
		"debug/plan9obj",
		"embed",
		"encoding",
		"encoding/ascii85",
		"encoding/asn1",
		"encoding/base32",
		"encoding/base64",
		"encoding/binary",
		"encoding/csv",
		"encoding/gob",
		"encoding/hex",
		"encoding/json",
		"encoding/pem",
		"encoding/xml",
		"errors",
		"expvar",
		"flag",
		"fmt",
		"go/ast",
		"go/build",
		"go/build/constraint",
		"go/constant",
		"go/doc",
		"go/format",
		"go/importer",
		"go/parser",
		"go/printer",
		"go/scanner",
		"go/token",
		"go/types",
		"hash",
		"hash/adler32",
		"hash/crc32",
		"hash/crc64",
		"hash/fnv",
		"hash/maphash",
		"html",
		"html/template",
		"image",
		"image/color",
		"image/color/palette",
		"image/draw",
		"image/gif",
		"image/jpeg",
		"image/png",
		"index/suffixarray",
		"io",
		"io/fs",
		"io/ioutil",
		"log",
		"log/slog",
		"log/syslog",
		"math",
		"math/big",
		"math/bits",
		"math/cmplx",
		"math/rand",
		"mime",
		"mime/multipart",
		"mime/quotedprintable",
		"net",
		"net/http",
		"net/http/cgi",
		"net/http/cookiejar",
		"net/http/fcgi",
		"net/http/httptest",
		"net/http/httptrace",
		"net/http/httputil",
		"net/http/pprof",
		"net/mail",
		"net/rpc",
		"net/rpc/jsonrpc",
		"net/smtp",
		"net/textproto",
		"net/url",
		"os",
		"os/exec",
		"os/signal",
		"os/user",
		"path",
		"path/filepath",
		"plugin",
		"reflect",
		"regexp",
		"regexp/syntax",
		"runtime",
		"runtime/cgo",
		"runtime/debug",
		"runtime/metrics",
		"runtime/pprof",
		"runtime/race",
		"runtime/trace",
		"sort",
		"strconv",
		"strings",
		"sync",
		"sync/atomic",
		"syscall",
		"testing",
		"testing/fstest",
		"testing/iotest",
		"testing/quick",
		"text/scanner",
		"text/tabwriter",
		"text/template",
		"text/template/parse",
		"time",
		"time/tzdata",
		"unicode",
		"unicode/utf16",
		"unicode/utf8",
		"unsafe",
	}, nil
}

func getExportedFunctionsAndTypes(pkgImportPath string) (string, []string, []string, error) {
	// This example assumes the package is in the standard library.
	// Use build to get the package details, which respects build tags.
	ctxt := build.Default
	ctxt.CgoEnabled = false
	ctxt.GOOS = runtime.GOOS
	ctxt.GOARCH = runtime.GOARCH
	pkg, err := ctxt.Import(pkgImportPath, "", 0)
	if err != nil {
		return "", nil, nil, fmt.Errorf("could not import package %s: %v", pkgImportPath, err)
	}

	fset := token.NewFileSet()
	funcSet := make(map[string]struct{})
	typeSet := make(map[string]struct{})
	var pkgName string
	for _, file := range pkg.GoFiles {
		f, err := parser.ParseFile(fset, filepath.Join(pkg.Dir, file), nil, 0)
		if err != nil {
			return "", nil, nil, fmt.Errorf("could not parse file %s: %v", file, err)
		}
		if pkgName == "" {
			pkgName = f.Name.Name
		}

		for _, decl := range f.Decls {
			if fn, ok := decl.(*ast.FuncDecl); ok {
				isGeneric := fn.Type.TypeParams != nil && fn.Type.TypeParams.NumFields() > 0
				// Only include functions, not methods.
				if fn.Recv == nil && fn.Name.IsExported() && !isGeneric &&
					!strings.HasPrefix(fn.Name.Name, "Test") &&
					!strings.HasPrefix(fn.Name.Name, "Example") &&
					!strings.HasPrefix(fn.Name.Name, "Benchmark") {
					funcSet[fn.Name.Name] = struct{}{}
				}
			}
			if gd, ok := decl.(*ast.GenDecl); ok {
				if gd.Tok == token.TYPE {
					for _, spec := range gd.Specs {
						if ts, ok := spec.(*ast.TypeSpec); ok {
							if ts.Name.IsExported() {
								typeSet[ts.Name.Name] = struct{}{}
							}
						}
					}
				}
				if gd.Tok == token.VAR || gd.Tok == token.CONST {
					for _, spec := range gd.Specs {
						if vs, ok := spec.(*ast.ValueSpec); ok {
							isGeneric := false
							if vs.Type != nil {
								if ft, ok := vs.Type.(*ast.FuncType); ok {
									if ft.TypeParams != nil && ft.TypeParams.NumFields() > 0 {
										isGeneric = true
									}
								}
							}
							if !isGeneric && len(vs.Values) > 0 {
								if fl, ok := vs.Values[0].(*ast.FuncLit); ok {
									if fl.Type.TypeParams != nil && fl.Type.TypeParams.NumFields() > 0 {
										isGeneric = true
									}
								}
							}
							if !isGeneric {
								for _, name := range vs.Names {
									if name.IsExported() {
										funcSet[name.Name] = struct{}{}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	var funcs []string
	for f := range funcSet {
		funcs = append(funcs, f)
	}
	sort.Strings(funcs)
	var types []string
	for t := range typeSet {
		types = append(types, t)
	}
	sort.Strings(types)
	return pkgName, funcs, types, nil
}
