package main

import (
	"fmt"
	"go/ast"
	"go/build"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"sort"
	"strings"
)

var excludedPackages = []string{
	"unsafe",
	"debug",
	"reflect",
	"runtime",
	"go",
	"syscall",
}

// ExcludedSymbol defines a symbol to be excluded from a specific package.
type ExcludedSymbol struct {
	Package string
	Symbol  string
}

var excludedSymbols = []ExcludedSymbol{
	{"hash/crc64", "ECMA"},
	{"hash/crc64", "ISO"},
	{"math", "MaxUint"},
	{"math", "MaxUint64"},
}

type PackageContent struct {
	PkgName string
	Funcs   []string
	Types   []string
}

func main() {
	// Get all standard library packages.
	stdPkgs, err := getStdPkgs()
	if err != nil {
		log.Fatalf("failed to get standard library packages: %v", err)
	}
	// Collect used packages and their exported symbols
	usedPkgs := make([]string, 0)
	usedPkgContent := make(map[string]PackageContent)

	for _, pkg := range stdPkgs {
		isExcluded := false
		for _, excluded := range excludedPackages {
			if pkg == excluded || strings.HasPrefix(pkg, excluded+"/") {
				isExcluded = true
				break
			}
		}
		if isExcluded {
			continue
		}
		pkgName, funcs, types, err := getExportedFunctionsAndTypes(pkg)
		if err != nil {
			log.Printf("failed to get exported functions for package %s: %v", pkg, err)
			continue
		}
		if err != nil {
			log.Printf("failed to get exported types for package %s: %v", pkg, err)
			continue
		}
		if len(funcs) > 0 {
			usedPkgs = append(usedPkgs, pkg)
			usedPkgContent[pkg] = PackageContent{pkgName, funcs, types}
		}
	}
	generateStdFuncsFile(usedPkgs, usedPkgContent)
	generateStdTypesFile(usedPkgs, usedPkgContent)
}

func generateStdFuncsFile(usedPkgs []string, usedPkgFuncs map[string]PackageContent) {

	// Create the output file.
	outFile, err := os.Create("../../pkg/stdlib_funcs_generated.go")
	if err != nil {
		log.Fatalf("failed to create output file: %v", err)
	}
	defer outFile.Close()

	// Write the header.
	fmt.Fprintln(outFile, "// Code generated by cmd/genstdlib/main.go; DO NOT EDIT.")
	fmt.Fprintln(outFile, "package pkg")
	fmt.Fprintln(outFile, "")

	// Assign unique aliases for each package
	pkgAliases := make(map[string]string)
	for idx, pkg := range usedPkgs {
		alias := fmt.Sprintf("i%d", idx+1)
		pkgAliases[pkg] = alias
	}

	fmt.Fprintln(outFile, "import (")
	fmt.Fprintln(outFile, "\t\"reflect\"")
	for _, pkg := range usedPkgs {
		alias := pkgAliases[pkg]
		fmt.Fprintf(outFile, "\t%s \"%s\"\n", alias, pkg)
	}
	fmt.Fprintln(outFile, ")")
	fmt.Fprintln(outFile, "\nvar stdfuncs = map[string]map[string]reflect.Value{}")
	fmt.Fprintln(outFile, "\nfunc init() {")

	for _, pkg := range usedPkgs {
		pkgInfo := usedPkgFuncs[pkg]
		alias := pkgAliases[pkg]
		fmt.Fprintf(outFile, "\tstdfuncs[\"%s\"] = map[string]reflect.Value{\n", pkg)
		for _, fun := range pkgInfo.Funcs {
			isExcluded := false
			for _, excluded := range excludedSymbols {
				if pkg == excluded.Package && fun == excluded.Symbol {
					isExcluded = true
					break
				}
			}
			if isExcluded {
				continue
			}
			fmt.Fprintf(outFile, "\t\t\"%s\": reflect.ValueOf(%s.%s),\n", fun, alias, fun)
		}
		fmt.Fprintln(outFile, "\t}")
	}

	fmt.Fprintln(outFile, "}")
}

func generateStdTypesFile(usedPkgs []string, usedPkgFuncs map[string]PackageContent) {

	// Create the output file.
	outFile, err := os.Create("../../pkg/stdlib_types_generated.go")
	if err != nil {
		log.Fatalf("failed to create output file: %v", err)
	}
	defer outFile.Close()

	// Write the header.
	fmt.Fprintln(outFile, "// Code generated by cmd/genstdlib/main.go; DO NOT EDIT.")
	fmt.Fprintln(outFile, "package pkg")
	fmt.Fprintln(outFile, "")

	// Assign unique aliases for each package
	pkgAliases := make(map[string]string)
	for idx, pkg := range usedPkgs {
		alias := fmt.Sprintf("i%d", idx+1)
		pkgAliases[pkg] = alias
	}

	fmt.Fprintln(outFile, "import (")
	fmt.Fprintln(outFile, "\t\"reflect\"")
	for _, pkg := range usedPkgs {
		alias := pkgAliases[pkg]
		pkgInfo := usedPkgFuncs[pkg]
		if len(pkgInfo.Types) == 0 {
			continue
		}
		fmt.Fprintf(outFile, "\t%s \"%s\"\n", alias, pkg)
	}
	fmt.Fprintln(outFile, ")")
	fmt.Fprintln(outFile, "\n// stdtypes maps package paths to their exported types as reflect.Value not reflect.Type")
	fmt.Fprintln(outFile, "var stdtypes = map[string]map[string]reflect.Value{}")
	fmt.Fprintln(outFile, "\nfunc init() {")

	for _, pkg := range usedPkgs {
		pkgInfo := usedPkgFuncs[pkg]
		alias := pkgAliases[pkg]
		if len(pkgInfo.Types) == 0 {
			continue
		}
		fmt.Fprintf(outFile, "\tstdtypes[\"%s\"] = map[string]reflect.Value{\n", pkg)
		for _, typ := range pkgInfo.Types {
			fmt.Fprintf(outFile, "\t\t\"%s\": makeReflect[%s.%s](),\n", typ, alias, typ)
		}
		fmt.Fprintln(outFile, "\t}")
	}

	fmt.Fprintln(outFile, "}")
}

func getExportedFunctionsAndTypes(pkgImportPath string) (string, []string, []string, error) {
	// This example assumes the package is in the standard library.
	// Use build to get the package details, which respects build tags.
	ctxt := build.Default
	ctxt.CgoEnabled = false
	ctxt.GOOS = runtime.GOOS
	ctxt.GOARCH = runtime.GOARCH
	pkg, err := ctxt.Import(pkgImportPath, "", 0)
	if err != nil {
		return "", nil, nil, fmt.Errorf("could not import package %s: %v", pkgImportPath, err)
	}

	fset := token.NewFileSet()
	funcSet := make(map[string]struct{})
	typeSet := make(map[string]struct{})
	var pkgName string
	for _, file := range pkg.GoFiles {
		f, err := parser.ParseFile(fset, filepath.Join(pkg.Dir, file), nil, 0)
		if err != nil {
			return "", nil, nil, fmt.Errorf("could not parse file %s: %v", file, err)
		}
		if pkgName == "" {
			pkgName = f.Name.Name
		}

		for _, decl := range f.Decls {
			if fn, ok := decl.(*ast.FuncDecl); ok {
				isGeneric := fn.Type.TypeParams != nil && fn.Type.TypeParams.NumFields() > 0
				// Only include functions, not methods.
				if fn.Recv == nil && fn.Name.IsExported() && !isGeneric &&
					!strings.HasPrefix(fn.Name.Name, "Test") &&
					!strings.HasPrefix(fn.Name.Name, "Example") &&
					!strings.HasPrefix(fn.Name.Name, "Benchmark") {
					funcSet[fn.Name.Name] = struct{}{}
				}
			}
			if gd, ok := decl.(*ast.GenDecl); ok {
				if gd.Tok == token.TYPE {
					for _, spec := range gd.Specs {
						if ts, ok := spec.(*ast.TypeSpec); ok {
							if ts.Name.IsExported() {
								isGeneric := ts.TypeParams != nil && ts.TypeParams.NumFields() > 0
								if _, ok := ts.Type.(*ast.StructType); ok && !isGeneric {
									typeSet[ts.Name.Name] = struct{}{}
								} else {
									//fmt.Printf("%s %T\n", ts.Name.Name, ts.Type)
								}
								if _, ok := ts.Type.(*ast.Ident); ok && !isGeneric {
									typeSet[ts.Name.Name] = struct{}{}
								}
							}
						}
					}
				}
				if gd.Tok == token.VAR || gd.Tok == token.CONST {
					for _, spec := range gd.Specs {
						if vs, ok := spec.(*ast.ValueSpec); ok {
							isGeneric := false
							if vs.Type != nil {
								if ft, ok := vs.Type.(*ast.FuncType); ok {
									if ft.TypeParams != nil && ft.TypeParams.NumFields() > 0 {
										isGeneric = true
									}
								}
							}
							if !isGeneric && len(vs.Values) > 0 {
								if fl, ok := vs.Values[0].(*ast.FuncLit); ok {
									if fl.Type.TypeParams != nil && fl.Type.TypeParams.NumFields() > 0 {
										isGeneric = true
									}
								}
							}
							if !isGeneric {
								for _, name := range vs.Names {
									if name.IsExported() {
										funcSet[name.Name] = struct{}{}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	var funcs []string
	for f := range funcSet {
		funcs = append(funcs, f)
	}
	sort.Strings(funcs)
	var types []string
	for t := range typeSet {
		types = append(types, t)
	}
	sort.Strings(types)
	fmt.Println("get exported functions and types for package:", pkgImportPath, "funcs:", len(funcs), "types:", len(types))
	return pkgName, funcs, types, nil
}
